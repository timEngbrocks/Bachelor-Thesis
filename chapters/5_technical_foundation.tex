\chapter{Technical Foundation}
\label{cha:technical_foundation}

% TODO: Check fits new third section
This chapter provides the technical foundations that are used for the solution that has been developed by this thesis.
These overviews do not go into detail about how they are used in this thesis but rather aim to provide
a foundation for the reader which is required by the following chapters.
Section \ref{sec:tech_containerization} explains the concept of containerization as well as the concepts of Kubernetes and Helm.
Section \ref{sec:tech_argocd} provides an overview of the CI/CD tool ArgoCD.
Section \ref{sec:tech_monitoring_systems} explains the concept of monitoring systems and their components. Additionally,
this section provides the foundations for the tools used by the monitoring solution that was developed for this thesis.

\section{Containerization}
\label{sec:tech_containerization}

% TODO: Do

Containerization is one of two possibilities to virtualize IT infrastructure.
The first possibility is virtualization through virtual machines.
The second possibility is containerization. The difference between virtual machines
and containerization is how they operate. This is visualized in Figure \ref{fig:vm_container_virtualization}.
Virtual machines run as a separate operating system on a computer.
They provide their own kernel and the hypervisor of the

\cite{DOC-DOCS}

\cite{KUB-DOCS}

\cite{HEL-DOCS}


\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{figures/vm_container_virtualization.png}
	\caption{VM vs. Container-Based Virtualization \cite{CM-W-CON}}
	\label{fig:vm_container_virtualization}
\end{figure}

\section{ArgoCD}
\label{sec:tech_argocd}

% TODO: Do

\cite{ARG-DOCS}

\section{Monitoring Systems}
\label{sec:tech_monitoring_systems}

% TODO: Finish

A complete monitoring system requires three main parts: Data sources, data sinks, and the ability
to analyze/visualize the collected data.
The collected data can be split into three different types
according to the three pillars of observability: Metrics, Logs, and Traces.
Because this work only focuses on metrics, logs and traces will be ignored for this explanation of monitoring systems.

Data sources are the origin of the collected metrics and can be split into two different types
based on how they acquire metrics. The first type is data sources that perform manual instrumentation.
This means that the application source code is amended by code that collects metrics and emits them.
Manual instrumentation is useful for application-specific metrics, like for example, how often a user
uses a certain feature in the application.
The second type is data sources that perform automatic instrumentation.
These data sources collect metrics from applications or the environment without changing any source code.
In contrast to manual instrumentation, automatic instrumentation is limited to collecting
common metrics that are provided by an application and its environment like CPU or memory usage.

Data sinks store the metrics that were collected by the data sources.
It is important to note that some data sinks specialize in which type of data they store
to increase efficiency. The last part is the analysis and visualization of the collected metrics.

Optionally, a monitoring system might employ additional components such as data transformers or collectors.
Data transformers can be used to transform data into different formats, enrich it with additional information
or aggregate it.
Data collectors can be used to buffer metrics that were sent by data sources before they are stored in a data sink,
which decreases the load on the data sink.

% \subsection{Grafana}

% % TODO: Grafana

% \cite{GRA-DOCS}

% Grafana is a tool for visualizing and querying time-series data.
% In Grafana you can build dashboards that visualize time-series data

% \subsection{Prometheus}

% % TODO: Prometheus

% \cite{PRO-DOCS}

% Prometheus is an open-source monitoring system.
% Prometheus can collect metrics by two different methods.
% Firstly, it can pull metrics from services via HTTP which is called scraping.
% Additionally, it can receive metrics via a push gateway to which services can send their metrics.
% Prometheus stores the collected metrics in a time-series database.
% A time-series database is a type of database that is optimized for data entries,
% which are associated with time. An example of this type of data is metrics and the time when they were collected.
% To analyze the collected metrics, Prometheus uses a query language called PromQL.

% \subsection{Grafana Mimir}

% % TODO: Grafana Mimir

% \cite{MIM-DOCS}

% Prometheus only stores its data on local disks which is
% Grafana Mimir offers long-term storage for Prometheus data.

% \subsection{MinIO}

% % TODO: MinIO

% \cite{MIN-DOCS}

% MinIO is an object storage that provides the same interface as Amazon Web Service's (AWS) S3 service.
% Object storage system store data as objects with a unique identifier. An object contains the data stored
% data itself and additional metadata. Objects can store arbitrary types of data.

% Storage systems can be divided into two categories by the type of data that they store.
% There are systems for structured data like relational or other types of databases.
% Then there are systems for unstructured data which need to be able to store random binary data.
% These systems for unstructured data can be divided into three categories: File storage, Block storage, and Object storage.
% File storage stores files in a hierarchical structure of folders and files.
% Files are identified by their path in the hierarchy and can be accessed by multiple users at a time.
% File storage is commonly used as the default storage system on most operating systems.
% Block storage stores files as chunks of data with a unique identifier. This increases access performance
% and reduces wasted memory from having to layout files contiguously in memory but it also increases complexity.
% Block storage is mostly used for systems that need minimal delay and consistent performance which are also
% able to expend the extra compute time needed for reassembling files from their separate chunks.
% Object storage combines the approaches of File and Block storage. Files are stored as objects that
% contain the file's data and additional metadata. They have a unique identifier for access and are laid out
% contiguously in memory. Object storage is mostly used for static data that needs to be read often but not written.
% This is because Object storage requires the complete retrieval and rewrite of an object when modifying it.
% Object storage reduces the complexity of the storage system compared to File and Block storage and increases
% performance for its specific use cases. One example of the use of object storage is the storage of
% assets for web pages like images or scripts. These assets don't have an overall structure which means
% that an unstructured storage system is best suited for their storage.
% Additionally, these assets need to be accessed more often than they need to be written.

% \cite{AMA-DOCS}

% One of the most popular object storage systems for cloud environments is Amazon Web Service's (AWS)
% S3; S3 means Simple Storage Service. AWS S3 is a paid service that implements the S3 interface for object storage.
% Contrary to AWS S3, the S3 interface is an open standard.
% MinIO was built as a free alternative to AWS S3 which implements the same interface.
% This way, MinIO can be used interchangeably with other services that rely on AWS S3 for storage.
% For this work, MinIO is used as part of the data sink for the monitoring solution.